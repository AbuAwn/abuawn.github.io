<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Configurador Solar Pro - Ingenier√≠a Sunfer</title>
    <style>
        :root {
            --accent: #ffcc00;
            --bg: #0a0a0a;
            --panel: rgba(20, 20, 20, 0.95);
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', 'Segoe UI', sans-serif;
            background-color: var(--bg);
            color: white;
            /* Prevent pull-to-refresh on mobile */
            overscroll-behavior: none;
        }

        /* UI Panel - Desktop Default */
        #ui-panel {
            position: absolute;
            top: 60px;
            /* Space for toggle button */
            left: 15px;
            background: var(--panel);
            padding: 18px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            width: 320px;
            backdrop-filter: blur(12px);
            border: 1px solid #333;
            z-index: 100;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
            scrollbar-width: thin;
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.3s ease;
            transform: translateX(0);
            opacity: 1;
        }

        /* Hiding state for Desktop and Mobile */
        #ui-panel.hidden {
            transform: translateX(-150%);
            opacity: 0;
            /* Helps performance/clicks */
            pointer-events: none;
        }

        /* Toggle Button - Always Visible */
        #toggle-btn {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 2000;
            background: var(--accent);
            color: black;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 800;
            font-size: 13px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        #toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(255, 204, 0, 0.3);
        }

        #toggle-btn:active {
            transform: translateY(0);
        }

        h2 {
            margin: 15px 0 8px 0;
            font-size: 11px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1.2px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }

        h2:first-child {
            margin-top: 0;
        }

        .group {
            margin-bottom: 12px;
        }

        label {
            display: block;
            font-size: 10px;
            color: #888;
            margin-bottom: 4px;
            font-weight: 600;
        }

        input,
        select {
            width: 100%;
            background: #1a1a1a;
            border: 1px solid #333;
            color: white;
            padding: 8px;
            border-radius: 6px;
            font-size: 12px;
            outline: none;
            transition: 0.2s;
            box-sizing: border-box;
            /* Fix padding issues */
        }

        input:focus,
        select:focus {
            border-color: var(--accent);
            background: #222;
        }

        input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .flex-row {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .flex-item {
            flex: 1;
            min-width: 0;
        }

        /* min-width fix for flex */

        .btn-action {
            background: var(--accent);
            color: black;
            border: none;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 800;
            font-size: 11px;
            width: 100%;
            text-transform: uppercase;
            margin-top: 5px;
        }

        .btn-action:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 204, 0, 0.3);
        }

        .move-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin: 10px 0;
        }

        .move-btn {
            background: #252525;
            border: 1px solid #444;
            color: white;
            height: 35px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .move-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .stat-box {
            background: rgba(255, 204, 0, 0.05);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 204, 0, 0.2);
            font-size: 11px;
            margin-top: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .stat-val {
            color: var(--accent);
            font-weight: bold;
        }

        .warning {
            padding: 8px;
            border-radius: 6px;
            font-size: 10px;
            margin-top: 10px;
            text-align: center;
            font-weight: bold;
        }

        .ok {
            background: rgba(46, 204, 113, 0.15);
            color: #2ecc71;
            border: 1px solid #2ecc71;
        }

        .err {
            background: rgba(231, 76, 60, 0.15);
            color: #e74c3c;
            border: 1px solid #e74c3c;
        }

        .row-selector {
            display: flex;
            gap: 4px;
            background: #111;
            padding: 4px;
            border-radius: 8px;
            margin: 8px 0;
        }

        .row-opt {
            flex: 1;
            text-align: center;
            font-size: 9px;
            padding: 6px 2px;
            border-radius: 6px;
            cursor: pointer;
            background: #222;
            border: 1px solid #333;
            color: #888;
        }

        .row-opt.active {
            background: var(--accent);
            color: black;
            font-weight: bold;
        }

        #help-tip {
            font-size: 9px;
            color: #aaa;
            margin-top: 8px;
            text-align: center;
            padding: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            border: 1px dashed #444;
        }

        /* Mobile / Tablet Responsive styles */
        @media (max-width: 1024px) {
            #ui-panel {
                top: 0;
                left: 0;
                width: 85%;
                max-width: 340px;
                height: 100vh;
                max-height: 100vh;
                border-radius: 0;
                border-right: 1px solid #444;
                box-shadow: 10px 0 50px rgba(0, 0, 0, 0.8);

                /* Start hidden on mobile */
                transform: translateX(-150%);
            }

            #ui-panel.mobile-view-open {
                transform: translateX(0);
                opacity: 1;
            }

            /* Increase touch targets */
            .btn-action,
            .move-btn,
            input,
            select {
                min-height: 44px;
                /* Mobile friendly */
            }

            label {
                font-size: 11px;
                margin-bottom: 6px;
            }

            #toggle-btn {
                top: 15px;
                left: 15px;
            }
        }
    </style>
</head>

<body>
    <button id="toggle-btn" onclick="toggleUI()">‚ò∞ Opciones</button>

    <div id="ui-panel">
        <h1
            style="text-align:center; color:#f1c40f; margin-bottom:15px; font-size:16px; border-bottom:1px solid #333; padding-bottom:10px;">
            Simulador Solar Pro
            <span style="font-size:10px; color:#888; font-weight:normal; margin-left:5px;">v1.10</span>
        </h1>
        <h2>1. Geometr√≠a del Tejado</h2>
        <div class="group">
            <label>Tipo de Cubierta</label>
            <select id="roofPreset" onchange="syncFromStandard()">
                <option value="trapecio">Trapecio Is√≥sceles</option>
                <option value="trapecio_recto" selected>Trapecio Rect√°ngulo</option>
                <option value="rectangulo">Rect√°ngulo</option>
            </select>
        </div>

        <div id="standard-dims">
            <div class="flex-row">
                <div class="flex-item group"><label>Base Inferior (m)</label><input type="number" id="roofB" value="8.3"
                        step="0.1" onchange="syncFromStandard()"></div>
                <div class="flex-item group"><label>Base Superior (m)</label><input type="number" id="roofT" value="5.8"
                        step="0.1" onchange="syncFromStandard()"></div>
            </div>
            <div class="flex-row">
                <div class="flex-item group"><label>Altura (m)</label><input type="number" id="roofH" value="2.5"
                        step="0.1" onchange="syncFromStandard()"></div>
                <div class="flex-item group"><label>Pendiente (¬∫)</label><input type="number" id="roofSlope" value="30"
                        onchange="updateView()"></div>
            </div>
        </div>

        <h2>2. Lista de Paneles</h2>
        <div class="group">
            <label>Modelo del Panel</label>
            <select id="panelPreset" onchange="applyPanelPreset()">
                <option value="ja450">JA Solar 450W (Voc 39.4V)</option>
                <option value="tensite" selected>Tensite 500W (Voc 43.1V)</option>
                <option value="trina">Trina Vertex S+ (Voc 52.9V)</option>
                <option value="tongwei">Tongwei 435W (Voc 43.8V)</option>
                <option value="custom">-- MANUAL / PERSONALIZADO --</option>
            </select>
        </div>

        <div class="flex-row">
            <div class="flex-item group"><label>Largo (mm)</label><input type="number" id="pLength" value="1961"
                    onchange="updateView()" disabled></div>
            <div class="flex-item group"><label>Ancho (mm)</label><input type="number" id="pWidth" value="1134"
                    onchange="updateView()" disabled></div>
        </div>

        <div class="flex-row">
            <div class="flex-item group"><label title="Voltaje de Circuito Abierto">Voc (V)</label><input type="number"
                    id="pVoc" value="43.1" step="0.1" onchange="renderPanels()" disabled></div>
            <div class="flex-item group"><label title="Voltaje Vmp a 70¬∞C">Vmp Calor (V)</label><input type="number"
                    id="pVmpH" value="31.0" step="0.1" onchange="renderPanels()" disabled></div>
        </div>

        <h2>3. Inversor (Umbrales)</h2>
        <div class="group">
            <label>Modelo de Inversor</label>
            <select id="invPreset" onchange="applyInverterPreset()">
                <option value="hoymiles">Hoymiles HYS-6.0LV (H√≠brido)</option>
                <option value="goodwe">GoodWe Serie EH / BH</option>
                <option value="fronius">Fronius Primo Gen24</option>
                <option value="sma">SMA Sunny Boy</option>
                <option value="custom">-- MANUAL / OTRO --</option>
            </select>
        </div>
        <div class="flex-row">
            <div class="flex-item group"><label title="Voltaje m√≠nimo para arrancar">V. Arranque (V)</label><input
                    type="number" id="invVstart" value="150" step="1" onchange="renderPanels()" disabled></div>
            <div class="flex-item group"><label title="Voltaje m√≠nimo de operaci√≥n">V. M√≠n Producci√≥n (V)</label><input
                    type="number" id="invVmin" value="125" step="1" onchange="renderPanels()" disabled></div>
        </div>

        <h2>4. Generador de Instalaci√≥n</h2>
        <div class="flex-row">
            <div class="flex-item group"><label>Filas</label><input type="number" id="genRows" value="1" min="1"
                    max="4"></div>
            <div class="flex-item group"><label>Paneles/Fila</label><input type="number" id="genCols" value="5" min="1"
                    max="8"></div>
        </div>
        <div class="group">
            <label>Orientaci√≥n Inicial</label>
            <select id="genOrient">
                <option value="v" selected>Vertical (Portrait)</option>
                <option value="h">Horizontal (Landscape)</option>
            </select>
        </div>
        <button class="btn-action" onclick="generateLayout()">Generar Nueva Matriz</button>
        <div id="help-tip">üéØ <b>Presor Intermedio:</b> 20mm respetados.<br><b>Doble clic</b> para eliminar un panel.
        </div>

        <h2>5. Ajuste de Posici√≥n</h2>
        <div class="row-selector">
            <div class="row-opt active" onclick="setMoveTarget('all')" id="tgt-all">Todo</div>
            <div class="row-opt" onclick="setMoveTarget(0)" id="tgt-0">Fila 1</div>
            <div class="row-opt" onclick="setMoveTarget(1)" id="tgt-1">Fila 2</div>
        </div>

        <div class="move-grid">
            <button class="move-btn" onclick="undo()" title="Deshacer" style="background:#555;">‚Ü∂</button><button
                class="move-btn" onclick="movePanel(0, 0.05)">‚ñ≤</button>
            <div></div>
            <button class="move-btn" onclick="movePanel(-0.1, 0)">‚óÄ</button>
            <button class="move-btn" onclick="generateLayout()">C</button>
            <button class="move-btn" onclick="movePanel(0.1, 0)">‚ñ∂</button>
            <div></div><button class="move-btn" onclick="movePanel(0, -0.05)">‚ñº</button>
            <div></div>
        </div>

        <h2>6. Estructura y Anclajes</h2>
        <div class="group">
            <label>Sistema de Anclaje</label>
            <select id="structPreset" onchange="renderStructureWrapper()">
                <option value="sunfer">Sunfer 02.3V (Coplanar Vertical)</option>
                <option value="generic_1230">Gen√©rico (Perfil 1230mm)</option>
                <option value="generic_2350">Gen√©rico (Perfil 2350mm)</option>
                <option value="manual">Manual / Personalizado</option>
            </select>
            <label style="display:flex; align-items:center; cursor:pointer; color:#eee; margin-top:10px;">
                <input type="checkbox" id="viewStructureOnly" onchange="renderStructureWrapper()"
                    style="width:auto; margin-right:8px;">
                Ocultar Paneles (Ver Estructura)
            </label>
            <label style="display:flex; align-items:center; cursor:pointer; color:#eee; margin-top:5px;">
                <input type="checkbox" id="viewDimensions" onchange="renderStructureWrapper()"
                    style="width:auto; margin-right:8px;">
                Ver Cotas (Distancias)
            </label>
            <div id="tile-align-opts" style="margin-top:8px; border-top:1px solid #333; padding-top:8px;">
                <label style="display:flex; align-items:center; cursor:pointer; color:#eee;">
                    <input type="checkbox" id="alignToTile" onchange="renderStructureWrapper()" checked
                        style="width:auto; margin-right:8px;">
                    Ajustar a Paso de Teja
                </label>
                <div class="flex-row" style="margin-top:5px;">
                    <div class="flex-item group"><label>Paso Teja (cm)</label><input type="number" id="tilePitch"
                            value="25" min="10" step="1" onchange="renderStructureWrapper()"></div>
                </div>
            </div>
            <div style="margin-top:10px; border-top:1px solid #333; padding-top:10px;">
                <label>Fuente de Precios</label>
                <select id="priceSourceSelect" onchange="applyPriceSource()">
                    <option value="obramat" selected>Obramat (Bricomart)</option>
                    <option value="leroy">Leroy Merlin</option>
                    <option value="carlos">Carlos Alcaraz</option>
                    <option value="alacen">Almac√©n Fotovoltaico</option>
                    <option value="manual">Manual</option>
                </select>
            </div>
        </div>

        <div id="generic-options" style="display:none; margin-top:5px; border-top:1px solid #333; padding-top:5px;">
            <div class="flex-row">
                <div class="flex-item group">
                    <label>Perfil (m)</label>
                    <select id="manualProfileSelect" onchange="syncManualProfile()"
                        style="width:100%; margin-bottom:5px;">
                        <option value="0.35">Micro 0.35m</option>
                        <option value="0.70">Corto 0.70m</option>
                        <option value="0.80">Corto 0.80m</option>
                        <option value="0.90">Medio 0.90m</option>
                        <option value="1.10">Medio 1.10m</option>
                        <option value="1.23">Est√°ndar 1.23m</option>
                        <option value="1.45">Largo 1.45m</option>
                        <option value="1.80">Largo 1.80m</option>
                        <option value="2.20">Extra 2.20m</option>
                        <option value="2.35" selected>Est√°ndar 2.35m</option>
                        <option value="3.60">Mega 3.60m</option>
                        <option value="4.40">Giga 4.40m</option>
                        <option value="4.80">Ultra 4.80m</option>
                        <option value="custom">Personalizado</option>
                    </select>
                    <input type="text" id="genRailLen" value="2.35" placeholder="Ej: 2.35+1.20"
                        onchange="renderStructureWrapper()"
                        title="Introduce longitudes en metros separadas por + (ej: 2.35+1.20)">
                </div>
                <div class="flex-item group" id="grp-spacing"><label>Sep. M√°x (m)</label><input type="number"
                        id="genSpacing" value="1.4" step="0.05" onchange="renderStructureWrapper()"></div>
                <div class="flex-item group" id="grp-anchors" style="display:none;"><label>Num. Anclajes</label><input
                        type="number" id="numAnchors" value="4" min="2" onchange="renderStructureWrapper()"></div>
            </div>
            <div id="manual-tip" style="display:none; color:#888; font-size:9px; margin-top:2px;">* Ajuste autom√°tico
                por seguridad (Voladizo 0.40m/Max 1.75m).</div>
        </div>
        <script>
            function syncManualProfile() {
                const sel = document.getElementById('manualProfileSelect');
                const inp = document.getElementById('genRailLen');
                if (sel.value !== 'custom') {
                    inp.value = sel.value;
                    // inp.disabled = true; // Optional: disable if strictly preset
                } else {
                    // inp.disabled = false;
                }
                renderStructureWrapper();
            }
        </script>

        <h3>Desglose de Materiales</h3>
        <div id="bom-container"
            style="background:rgba(255,255,255,0.05); padding:8px; border-radius:6px; font-size:10px; margin-bottom:15px; border:1px dashed #444;">
            <div style="color:#888; font-style:italic;">Genere una matriz para ver componentes.</div>
        </div>

        <div class="stat-box">
            <div class="stat-row"><span>Voc (Arranque):</span> <span id="st-voc" class="stat-val">0 V</span></div>
            <div class="stat-row"><span>Vmp (Calor):</span> <span id="st-vmp" class="stat-val">0 V</span></div>
            <div class="stat-row"><span>Paneles Reales:</span> <span id="st-count" class="stat-val">0</span></div>
        </div>
        <div id="safety-msg" class="warning ok">DISE√ëO CORRECTO</div>

        <h2>7. Gesti√≥n de Proyecto</h2>
        <div class="flex-row">
            <button class="flex-item btn-action" style="background:#2ecc71; color:black;" onclick="saveProject()">üíæ
                Guardar</button>
            <button class="flex-item btn-action" style="background:#3498db; color:black;"
                onclick="document.getElementById('file-input').click()">üìÇ Cargar</button>
            <input type="file" id="file-input" style="display:none" accept=".json" onchange="loadProject(this)">
        </div>
        <div class="flex-row" style="margin-top:5px;">
            <button class="flex-item btn-action" style="background:#e67e22; color:white;" onclick="exportCSV()">üìä
                Excel/CSV</button>
            <button class="flex-item btn-action" style="background:#c0392b; color:white;" onclick="exportPDF()">üìÑ
                PDF</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls, roofMesh, panelsGroup;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let hoveredPanel = null;

        let vertices = [];
        let panels = [];
        let moveTarget = 'all';
        let bomPrices = {};

        // Constantes globales de instalaci√≥n
        const P_GAP = 0.02; // Separaci√≥n de 20mm exacta para presores intermedios Sunfer
        const P_SAFE = 0.08; // Margen de seguridad para anclajes (m)

        const panelPresets = {
            ja450: { l: 1762, w: 1134, voc: 39.4, vmpH: 28.3 },
            tensite: { l: 1961, w: 1134, voc: 43.1, vmpH: 31.0 },
            trina: { l: 1762, w: 1134, voc: 52.9, vmpH: 38.3 },
            tongwei: { l: 1899, w: 1096, voc: 43.8, vmpH: 31.1 }
        };

        const inverterPresets = {
            hoymiles: { vstart: 150, vmin: 125 },
            goodwe: { vstart: 100, vmin: 80 },
            fronius: { vstart: 80, vmin: 80 },
            sma: { vstart: 100, vmin: 100 }
        };

        // Undo System
        let historyStack = [];

        function saveState() {
            if (historyStack.length > 50) historyStack.shift();
            historyStack.push(JSON.stringify(panels));
        }

        function undo() {
            if (historyStack.length === 0) return;
            try {
                const prev = historyStack.pop();
                panels = JSON.parse(prev);
                updateView(); // Rerender
            } catch (e) {
                console.error("Undo error", e);
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(12, 10, 15);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const sun = new THREE.DirectionalLight(0xffffff, 0.6);
            sun.position.set(5, 20, 10);
            scene.add(sun);

            panelsGroup = new THREE.Group();
            scene.add(panelsGroup);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('dblclick', onPanelDelete);

            // Mobile Detection & Click Outside Listener
            window.addEventListener('resize', updateUIState);
            document.addEventListener('click', (e) => {
                const ui = document.getElementById('ui-panel');
                const btn = document.getElementById('toggle-btn');
                const isMobile = window.innerWidth <= 1024;

                // Close if clicking outside on mobile (and panel is open)
                if (isMobile && ui.classList.contains('mobile-view-open')) {
                    if (!ui.contains(e.target) && !btn.contains(e.target)) {
                        toggleUI();
                    }
                }
            });

            syncFromStandard();
            generateLayout();
            animate();

            // Normalize UI state on load
            updateUIState();
        }

        function updateUIState() {
            const ui = document.getElementById('ui-panel');
            const btn = document.getElementById('toggle-btn');
            const isMobile = window.innerWidth <= 1024;

            let isOpen = false;

            if (isMobile) {
                // Mobile Mode
                isOpen = ui.classList.contains('mobile-view-open');
                // Ensure desktop class is removed to avoid conflicts
                ui.classList.remove('hidden');
            } else {
                // Desktop Mode
                // Check if hidden (collapsed)
                const isHidden = ui.classList.contains('hidden');
                ui.classList.remove('mobile-view-open');
                isOpen = !isHidden;
            }

            btn.innerHTML = isOpen
                ? `<span style="font-size:16px;">‚úï</span> CERRAR`
                : `<span style="font-size:16px;">‚ò∞</span> OPCIONES`;
        }

        function applyPanelPreset() {
            const p = document.getElementById('panelPreset').value;
            const custom = p === 'custom';
            ['pLength', 'pWidth', 'pVoc', 'pVmpH'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.disabled = !custom;
            });

            if (!custom) {
                const data = panelPresets[p];
                document.getElementById('pLength').value = data.l;
                document.getElementById('pWidth').value = data.w;
                document.getElementById('pVoc').value = data.voc;
                document.getElementById('pVmpH').value = data.vmpH;
            }
            updateView();
        }

        function applyInverterPreset() {
            const i = document.getElementById('invPreset').value;
            const custom = i === 'custom';
            ['invVstart', 'invVmin'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.disabled = !custom;
            });

            if (!custom) {
                const data = inverterPresets[i];
                document.getElementById('invVstart').value = data.vstart;
                document.getElementById('invVmin').value = data.vmin;
            }
            renderPanels();
        }

        function onMouseMove(event) {
            // Prevent raycasting if hovering over UI or other elements
            if (event.target.tagName !== 'CANVAS') {
                if (hoveredPanel) resetHighlight(hoveredPanel);
                hoveredPanel = null;
                return;
            }

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(panelsGroup.children, true);

            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while (obj.parent && !obj.userData.id) obj = obj.parent;

                if (hoveredPanel !== obj) {
                    if (hoveredPanel) resetHighlight(hoveredPanel);
                    hoveredPanel = obj;
                    highlightPanel(hoveredPanel);
                }
            } else {
                if (hoveredPanel) resetHighlight(hoveredPanel);
                hoveredPanel = null;
            }
        }

        function highlightPanel(obj) {
            obj.children.forEach(child => {
                if (child instanceof THREE.LineSegments) child.material.color.set(0xffffff);
            });
        }

        function resetHighlight(obj) {
            obj.children.forEach(child => {
                if (child instanceof THREE.LineSegments) child.material.color.set(0x444444);
            });
        }

        function onPanelDelete() {
            if (hoveredPanel && hoveredPanel.userData.id) {
                panels = panels.filter(p => p.id !== hoveredPanel.userData.id);
                renderPanels();
                hoveredPanel = null;
            }
        }

        function isPointInPoly(pt, poly) {
            let inside = false;
            for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
                let xi = poly[i].x, yi = poly[i].y;
                let xj = poly[j].x, yj = poly[j].y;
                let intersect = ((yi > pt.y) != (yj > pt.y)) && (pt.x < (xj - xi) * (pt.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function checkSafety(p) {
            const corners = [
                { x: p.x, y: p.y }, { x: p.x + p.w, y: p.y },
                { x: p.x, y: p.y + p.h }, { x: p.x + p.w, y: p.y + p.h }
            ];
            const anchors = [
                { x: p.x + p.w * 0.2, y: p.y + p.h * 0.25 }, { x: p.x + p.w * 0.8, y: p.y + p.h * 0.25 },
                { x: p.x + p.w * 0.2, y: p.y + p.h * 0.75 }, { x: p.x + p.w * 0.8, y: p.y + p.h * 0.75 }
            ];
            const allCornersIn = corners.every(c => isPointInPoly(c, vertices));
            const allAnchorsIn = anchors.every(a => isPointInPoly(a, vertices));
            if (allCornersIn) return 'ok';
            if (allAnchorsIn) return 'warn';
            return 'err';
        }

        // Datos oficiales SUNFER 02.3V
        const sunferData = {
            1: { anchors: 2, railLen: 1230, spacings: [800], edge: 215, bom: { s02_3: 4, s10: 4, s11: 0, ug1: 0, g1_1230: 2, g1_1800: 0, g1_550: 0, tapa: 4, s13: 4 } },
            2: { anchors: 2, railLen: 2460, spacings: [1400], edge: 530, bom: { s02_3: 4, s10: 4, s11: 2, ug1: 2, g1_1230: 4, g1_1800: 0, g1_550: 0, tapa: 4, s13: 6 } },
            3: { anchors: 3, railLen: 3600, spacings: [1400, 1400], edge: [300, 500], bom: { s02_3: 6, s10: 4, s11: 4, ug1: 2, g1_1230: 0, g1_1800: 4, g1_550: 0, tapa: 4, s13: 8 } },
            4: { anchors: 3, railLen: 4830, spacings: [1770, 1770], edge: 645, bom: { s02_3: 6, s10: 4, s11: 6, ug1: 4, g1_1230: 2, g1_1800: 4, g1_550: 0, tapa: 4, s13: 10 } },
            5: { anchors: 4, railLen: 5950, spacings: [1700, 1700, 1700], edge: 425, bom: { s02_3: 8, s10: 4, s11: 8, ug1: 6, g1_1230: 0, g1_1800: 6, g1_550: 2, tapa: 4, s13: 12 } },
            6: { anchors: 5, railLen: 7200, spacings: [1600, 1500, 1700, 1600], edge: 400, bom: { s02_3: 10, s10: 4, s11: 10, ug1: 6, g1_1230: 0, g1_1800: 8, g1_550: 0, tapa: 4, s13: 14 } }
        };

        function renderStructureWrapper() {
            renderPanels();
        }


        function updateBOM(totalBom) {
            const container = document.getElementById('bom-container');
            if (!totalBom) {
                container.innerHTML = '<div style="color:#666; font-style:italic;">Sin datos.</div>';
                return;
            }
            let html = '<table style="width:100%; border-collapse:collapse; color:#ddd; font-family:monospace; font-size:11px;">';
            html += '<thead style="color:#888; border-bottom:1px solid #444;"><tr><th style="text-align:left; padding-bottom:4px;">Concepto</th><th style="text-align:right;">Cant.</th><th style="text-align:right;">Precio/Ud</th><th style="text-align:right;">Total</th></tr></thead>';
            html += '<tbody>';

            const labels = {
                s02_3: { n: 'Soporte S02.3', c: '#ff4500' },
                s10: { n: 'Presor Lat. S10', c: '#e74c3c' },
                s11: { n: 'Presor Cen. S11', c: '#2ecc71' },
                ug1: { n: 'UG1 de Sunfer', c: '#2980b9' },
                g1_0350: { n: 'Perfil G1-350', c: '#ecf0f1' },
                g1_0700: { n: 'Perfil G1-700', c: '#bdc3c7' },
                g1_0800: { n: 'Perfil G1-800', c: '#95a5a6' },
                g1_0900: { n: 'Perfil G1-900', c: '#7f8c8d' },
                g1_1100: { n: 'Perfil G1-1100', c: '#aed6f1' },
                g1_1230: { n: 'Perfil G1-1230', c: '#3498db' }, // Blue
                g1_1450: { n: 'Perfil G1-1450', c: '#5dade2' },
                g1_1800: { n: 'Perfil G1-1800', c: '#1abc9c' },
                g1_2200: { n: 'Perfil G1-2200', c: '#8e44ad' }, // Dark Purple
                g1_2350: { n: 'Perfil G1-2350', c: '#9b59b6' }, // Purple
                g1_3600: { n: 'Perfil G1-3600', c: '#27ae60' }, // Dark Green
                g1_4400: { n: 'Perfil G1-4400', c: '#d35400' }, // Orange
                g1_4800: { n: 'Perfil G1-4800', c: '#c0392b' }, // Dark Red
                g1_550: { n: 'Perfil G1-550', c: '#95a5a6' },
                tapa: { n: 'Tapa G1', c: '#111111' },
                s13: { n: 'Torniller√≠a S13', c: '#ffffff' },
                g_rail: { n: 'Perfil Gen√©rico', c: '#c0c0c0' },
                g_anc: { n: 'Anclaje Gen√©rico', c: '#3498db' },
                g_union: { n: 'UG1 de Sunfer', c: '#2980b9' }
            };

            const priceSources = {
                obramat: {
                    name: 'Obramat',
                    prices: { s02_3: 8.50, s10: 1.80, s11: 1.80, ug1: 3.50, g_union: 3.50, g1_2350: 17.95, g1_4400: 35.00 }
                },
                leroy: {
                    name: 'Leroy Merlin',
                    prices: { s02_3: 14.99, s10: 2.50, s11: 2.50, ug1: 5.99, g_union: 5.99, g1_2350: 22.95, g1_4400: 45.00 }
                },
                carlos: {
                    name: 'Carlos Alcaraz',
                    prices: { s02_3: 9.20, s10: 1.95, s11: 1.95, ug1: 3.90, g_union: 3.90, g1_2350: 18.50, g1_4400: 36.50 }
                },
                alacen: {
                    name: 'Almac√©n Fotovoltaico',
                    prices: { s02_3: 7.90, s10: 1.65, s11: 1.65, ug1: 3.20, g_union: 3.20, g1_2350: 16.50, g1_4400: 33.00 }
                },
                manual: { name: 'Manual / Propio', prices: {} }
            };

            let grandTotal = 0;

            for (const k in totalBom) {
                if (totalBom[k] > 0) {
                    const item = labels[k] || { n: k, c: '#fff' };
                    const qty = totalBom[k];
                    const price = bomPrices[k] || 0;
                    const sub = qty * price;
                    grandTotal += sub;

                    html += `
                            <tr style="border-bottom:1px solid #222;">
                                <td style="padding:6px 0;">
                                    <span style="display:inline-block; width:8px; height:8px; background-color:${item.c}; margin-right:5px; border-radius:2px;"></span>
                                    ${item.n}
                                </td>
                                <td style="text-align:right; font-weight:bold; color:#ffcc00;">${qty}</td>
                                <td style="text-align:right;">
                                    <input type="number" step="0.01" placeholder="0.00" value="${price > 0 ? price : ''}" 
                                        style="width:50px; background:#222; border:1px solid #444; color:white; padding:2px 4px; border-radius:4px; text-align:right; font-size:11px;"
                                        onchange="updateBomPrice('${k}', this.value, ${qty})"> ‚Ç¨
                                </td>
                                <td style="text-align:right; font-weight:bold;" id="sub-${k}">
                                    ${sub > 0 ? sub.toFixed(2) : '0.00'} ‚Ç¨
                                </td>
                            </tr>`;
                }
            }
            html += '</tbody>';
            html += `<tfoot style="border-top:2px solid #444;">
                        <tr>
                            <td colspan="3" style="text-align:right; padding-top:8px; color:#aaa;">TOTAL PRESUPUESTO:</td>
                            <td style="text-align:right; padding-top:8px; color:#2ecc71; font-weight:bold; font-size:13px;" id="bom-total">
                                ${grandTotal.toFixed(2)} ‚Ç¨
                            </td>
                        </tr>
                     </tfoot>`;
            html += '</table>';
            container.innerHTML = html;
        }

        function updateBomPrice(key, val, qty) {
            const price = parseFloat(val) || 0;
            bomPrices[key] = price;

            // Subtotal
            const sub = price * qty;
            const subEl = document.getElementById('sub-' + key);
            if (subEl) subEl.innerHTML = sub.toFixed(2) + ' ‚Ç¨';

            // Grand Total
            let sum = 0;
            document.querySelectorAll('[id^="sub-"]').forEach(el => {
                const t = parseFloat(el.innerText.replace(' ‚Ç¨', '')) || 0;
                sum += t;
            });
            const totEl = document.getElementById('bom-total');
            if (totEl) totEl.innerHTML = sum.toFixed(2) + ' ‚Ç¨';
        }

        // URL del Cloudflare Worker (actualiza esto despu√©s de desplegar)
        const WORKER_URL = 'https://solar-price-scraper.YOUR-ACCOUNT.workers.dev';

        async function applyPriceSource() {
            const src = document.getElementById('priceSourceSelect').value;

            if (src === 'manual') {
                // Modo manual: no hacer nada, dejar que el usuario edite
                return;
            }

            // Mostrar indicador de carga
            const selectEl = document.getElementById('priceSourceSelect');
            const originalHTML = selectEl.innerHTML;
            selectEl.disabled = true;
            selectEl.innerHTML = '<option>Actualizando precios...</option>';

            try {
                // Intentar obtener precios del worker
                const response = await fetch(`${WORKER_URL}/prices?source=${src}`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });

                if (response.ok) {
                    const data = await response.json();

                    if (data.success && data.prices) {
                        // Actualizar precios con los datos del worker
                        for (let k in data.prices) {
                            if (data.prices[k] > 0) {
                                bomPrices[k] = data.prices[k];
                            }
                        }

                        console.log(`‚úÖ Precios actualizados desde ${data.source}:`, data.prices);

                        // Mostrar notificaci√≥n de √©xito
                        showNotification(`Precios actualizados desde ${src}`, 'success');
                    } else {
                        throw new Error('Respuesta inv√°lida del servidor');
                    }
                } else {
                    throw new Error(`Error HTTP: ${response.status}`);
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Error obteniendo precios del worker, usando fallback:', error);

                // Fallback a precios locales
                const fallbackPrices = {
                    obramat: {
                        s02_3: 8.50, s10: 1.80, s11: 1.80, ug1: 3.50, g_union: 3.50,
                        g1_1230: 8.99, g1_1800: 14.00, g1_2350: 17.95, g1_3600: 30.99, g1_4400: 35.00,
                        tapa: 0.75, s13: 0.30
                    },
                    leroy: {
                        s02_3: 14.99, s10: 2.50, s11: 2.50, ug1: 5.99, g_union: 5.99,
                        g1_1230: 12.50, g1_1800: 18.00, g1_2350: 22.95, g1_3600: 38.00, g1_4400: 45.00,
                        tapa: 1.20, s13: 0.50
                    },
                    carlos: {
                        s02_3: 9.20, s10: 1.95, s11: 1.95, ug1: 3.90, g_union: 3.90,
                        g1_1230: 9.50, g1_1800: 15.00, g1_2350: 18.50, g1_3600: 32.00, g1_4400: 36.50,
                        tapa: 0.85, s13: 0.35
                    },
                    alacen: {
                        s02_3: 7.90, s10: 1.65, s11: 1.65, ug1: 3.20, g_union: 3.20,
                        g1_1230: 7.50, g1_1800: 12.50, g1_2350: 16.50, g1_3600: 28.00, g1_4400: 33.00,
                        tapa: 0.60, s13: 0.25
                    }
                };

                if (fallbackPrices[src]) {
                    for (let k in fallbackPrices[src]) {
                        bomPrices[k] = fallbackPrices[src][k];
                    }
                    showNotification(`Usando precios de referencia (${src})`, 'warning');
                }
            } finally {
                // Restaurar selector
                selectEl.disabled = false;
                selectEl.innerHTML = originalHTML;
                selectEl.value = src;

                // Actualizar vista
                renderStructureWrapper();
            }
        }

        function showNotification(message, type = 'info') {
            // Crear elemento de notificaci√≥n
            const notif = document.createElement('div');
            notif.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 20px;
                border-radius: 8px;
                color: white;
                font-weight: bold;
                z-index: 10000;
                animation: slideIn 0.3s ease;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;

            if (type === 'success') {
                notif.style.background = '#2ecc71';
            } else if (type === 'warning') {
                notif.style.background = '#f39c12';
            } else {
                notif.style.background = '#3498db';
            }

            notif.textContent = message;
            document.body.appendChild(notif);

            // Eliminar despu√©s de 3 segundos
            setTimeout(() => {
                notif.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notif.remove(), 300);
            }, 3000);
        }

        // A√±adir estilos de animaci√≥n
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(400px); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(400px); opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        function renderStructure(parentGroup) {
            const modeEl = document.getElementById('structPreset');
            const genRailEl = document.getElementById('genRailLen');
            const genSpaceEl = document.getElementById('genSpacing');
            const numAnchorsEl = document.getElementById('numAnchors');
            const grpSpacing = document.getElementById('grp-spacing');
            const grpAnchors = document.getElementById('grp-anchors');
            const tipEl = document.getElementById('manual-tip');
            const optsDiv = document.getElementById('generic-options');

            if (!modeEl) return;
            const mode = modeEl.value;
            const isManual = (mode === 'manual');

            // Mostrar opciones manuales solo si es custom
            if (optsDiv) optsDiv.style.display = (mode.startsWith('generic') || isManual) ? 'block' : 'none';
            if (grpSpacing) grpSpacing.style.display = isManual ? 'none' : 'block';
            if (grpAnchors) grpAnchors.style.display = isManual ? 'block' : 'none';
            if (tipEl) tipEl.style.display = isManual ? 'block' : 'none';

            if (mode === 'generic_1230' && document.activeElement !== genRailEl) { genRailEl.value = 1.23; genSpaceEl.value = 0.8; }
            if (mode === 'generic_2350' && document.activeElement !== genRailEl) { genRailEl.value = 2.35; genSpaceEl.value = 1.4; }

            if (genRailEl) genRailEl.disabled = false; // Always enabled for manual tweaking? Or just for manual? Keeping consistent with previous logic
            if (genSpaceEl) genSpaceEl.disabled = isManual; // Disable spacing calc input if manual anchors used

            const totalBom = {
                s02_3: 0, s10: 0, s11: 0, ug1: 0,
                g1_0350: 0, g1_0700: 0, g1_0800: 0, g1_0900: 0, g1_1100: 0,
                g1_1230: 0, g1_1450: 0, g1_1800: 0,
                g1_2200: 0, g1_2350: 0,
                g1_3600: 0, g1_4400: 0, g1_4800: 0, g1_550: 0,
                tapa: 0, s13: 0, g_rail: 0, g_anc: 0, g_union: 0
            };
            const verticalRailPositions = new Set();
            const rows = {};
            panels.forEach(p => {
                if (!rows[p.row]) rows[p.row] = [];
                rows[p.row].push(p);
            });

            Object.keys(rows).forEach(rKey => {
                const rowPanels = rows[rKey];
                const n = rowPanels.length;
                if (n === 0) return;

                // Sort panels by x position to find gaps accurately
                rowPanels.sort((a, b) => a.x - b.x);

                let minX = Infinity, maxX = -Infinity;
                let yPos = rowPanels[0].y;
                let pHeight = rowPanels[0].h;

                rowPanels.forEach(p => {
                    minX = Math.min(minX, p.x);
                    maxX = Math.max(maxX, p.x + p.w);
                });

                const panelSpan = maxX - minX;
                const centerX = (minX + maxX) / 2;
                const railZ = 0.05;

                // Definir geometr√≠a del riel y anclajes
                let railLen = panelSpan, startX = minX;
                let anchorsCoords = [];
                let segments = [];
                let isSunfer = (mode === 'sunfer');
                let railUnit = parseFloat(genRailEl.value) || 2.35;

                if (isSunfer && sunferData[n]) {
                    const d = sunferData[n];
                    railLen = d.railLen / 1000;
                    startX = centerX - railLen / 2;

                    let cx = startX;
                    if (Array.isArray(d.edge)) {
                        cx += d.edge[0] / 1000;
                    } else {
                        cx += d.edge / 1000;
                    }

                    // Primer anclaje
                    anchorsCoords.push(cx);

                    // Resto de anclajes
                    for (let i = 0; i < d.spacings.length; i++) {
                        cx += d.spacings[i] / 1000;
                        anchorsCoords.push(cx);
                    }

                    // BOM
                    for (let k in d.bom) totalBom[k] += d.bom[k];

                } else {
                    // --- L√ìGICA DE INGENIER√çA MEJORADA (Manual y Gen√©rico) ---
                    // "Regla de Oro": Prioridad Voladizo (Cantilever) y L√≠mite de Flexi√≥n (Max Span)

                    const CANTILEVER = 0.40;   // Voladizo fijo para bordes (seguridad viento)

                    // Definir MAX_SPAN:
                    // - Si es Gen√©rico: Usar el valor 'Sep. M√°x' del input (ej: 0.8m o 1.4m seg√∫n perfil)
                    // - Si es Manual: Usar el l√≠mite estructural de seguridad (1.75m)
                    let MAX_SPAN = 1.75;
                    if (mode.startsWith('generic')) {
                        MAX_SPAN = parseFloat(genSpaceEl.value) || 1.75;
                    }

                    // Longitud total del riel: PanelSpan + 10cm extra (5cm por lado)
                    railLen = panelSpan + 0.1;

                    // Distancia √∫til entre anclajes extremos
                    let distBetweenExtremes = railLen - (2 * CANTILEVER);
                    if (distBetweenExtremes <= 0) distBetweenExtremes = railLen - 0.2; // Fallback para rieles muy cortos

                    // N√∫mero inicial de anclajes
                    // Si es manual, cogemos el input (min 2). Si es gen√©rico, empezamos con 2 y el algoritmo corrige.
                    let numAnc = (mode === 'manual') ? (parseInt(numAnchorsEl.value) || 2) : 2;
                    if (numAnc < 2) numAnc = 2;

                    // Auto-correcci√≥n de seguridad: A√±adir anclajes si el vano supera 1.75m
                    let currentSpan = distBetweenExtremes / Math.max(1, numAnc - 1);
                    while (currentSpan > MAX_SPAN) {
                        numAnc++;
                        currentSpan = distBetweenExtremes / (numAnc - 1);
                    }

                    // UI Inteligente: Actualizar el input si el c√°lculo de ingenier√≠a requiri√≥ m√°s anclajes
                    if (isManual && document.activeElement !== numAnchorsEl && numAnchorsEl) {
                        numAnchorsEl.value = numAnc;
                    }

                    // Generar Coordenadas
                    // Generar Coordenadas
                    const startAnc = (centerX - railLen / 2) + CANTILEVER;
                    const endAncLimit = (centerX + railLen / 2) - CANTILEVER;

                    const alignTile = document.getElementById('alignToTile')?.checked;
                    const pitchCm = parseFloat(document.getElementById('tilePitch')?.value) || 25;
                    const pitch = pitchCm / 100;

                    if (alignTile) {
                        // Logic for Tile Alignment
                        // 1. Find first grid point >= startAnc
                        // Note: Using global grid system logic (relative to 0) or relative to roof edge?
                        // Let's assume global grid for consistency.

                        let firstGrid = Math.ceil(startAnc / pitch) * pitch;
                        // Avoid snapping too far if it violates cantilever too much?
                        // For now, strict grid.

                        let current = firstGrid;
                        anchorsCoords = [];

                        // We need to cover up to endAncLimit
                        // Max span logic:
                        const maxStep = Math.floor(MAX_SPAN / pitch) * pitch;

                        if (current <= endAncLimit + 0.05) { // Tolerance
                            anchorsCoords.push(current);
                        } else {
                            // Rail too short or pitch too big, force center or start
                            anchorsCoords.push(startAnc);
                        }

                        // Fill rest
                        while (current < endAncLimit) {
                            let next = current + maxStep;
                            // Ensure we don't exceed limit significantly, but we must reach near end
                            if (next > endAncLimit) {
                                // Close the gap. Check if gap to end limit is > MAX_SPAN implies we need an intermediate
                                // But effectively we just place the last anchor at the last valid grid point
                                next = Math.floor(endAncLimit / pitch) * pitch;
                                if (next <= current) break; // Should not happen unless pitch > span
                            }

                            // Check valid gap
                            if (next - current > MAX_SPAN + 0.01) {
                                // This grid step is too large! (should be covered by maxStep logic unless pitch > MAX_SPAN)
                                // Fallback: add intermediate
                                next = current + pitch;
                            }

                            if (!anchorsCoords.includes(next)) anchorsCoords.push(next);
                            current = next;
                        }
                    } else {
                        // Legacy Equidistant Logic
                        for (let k = 0; k < numAnc; k++) {
                            anchorsCoords.push(startAnc + k * currentSpan);
                        }
                    }

                    // GENERACI√ìN DE RIELES Y UNIONES (Optimizado con Anti-Colisi√≥n de Presores)
                    railUnit = parseFloat(genRailEl.value) || 2.35;
                    segments = [];

                    // 1. Calcular posiciones relativas de los presores (Clamps)
                    // Se asume que el riel comienza en startX = centerX - railLen / 2
                    // Los presores est√°n entre paneles.
                    let clampRelPositions = [];
                    // El ancho de la zona "prohibida" para una uni√≥n es aprox el ancho del presor + margen
                    // Presor = 2cm a 4cm. Uni√≥n = 10cm. 
                    // Si el centro de la uni√≥n cae a menos de X cm del centro del presor, colisi√≥n.
                    const COLLISION_THRESHOLD = 0.12; // 12cm de margen total (6cm por lado)

                    for (let i = 0; i < n - 1; i++) {
                        const pCur = rowPanels[i];
                        const pNext = rowPanels[i + 1];
                        const midX = (pCur.x + pCur.w + pNext.x) / 2;
                        const relX = midX - (centerX - railLen / 2);
                        clampRelPositions.push(relX);
                    }

                    // 2. OPTIMIZACI√ìN AVANZADA DE RIELES (Smart Mix & Alternation)
                    // Buscamos la combinaci√≥n m√°s econ√≥mica y robusta (sin colisiones)
                    if (!isSunfer) {
                        // Definir Stock Completo con Precios Actualizados
                        const getPrice = (k, def) => (typeof bomPrices !== 'undefined' && bomPrices[k]) ? bomPrices[k] : def;

                        const stock = [
                            { len: 4.80, cost: getPrice('g1_4800', 38.00), k: 'g1_4800' },
                            { len: 4.40, cost: getPrice('g1_4400', 35.00), k: 'g1_4400' },
                            { len: 3.60, cost: getPrice('g1_3600', 30.99), k: 'g1_3600' },
                            { len: 2.35, cost: getPrice('g1_2350', 17.95), k: 'g1_2350' },
                            { len: 2.20, cost: getPrice('g1_2200', 18.00), k: 'g1_2200' },
                            { len: 1.80, cost: getPrice('g1_1800', 14.00), k: 'g1_1800' },
                            { len: 1.45, cost: getPrice('g1_1450', 10.00), k: 'g1_1450' },
                            { len: 1.23, cost: getPrice('g1_1230', 8.99), k: 'g1_1230' },
                            { len: 1.10, cost: getPrice('g1_1100', 7.00), k: 'g1_1100' },
                            { len: 0.90, cost: getPrice('g1_0900', 6.00), k: 'g1_0900' },
                            { len: 0.80, cost: getPrice('g1_0800', 5.00), k: 'g1_0800' },
                            { len: 0.70, cost: getPrice('g1_0700', 4.50), k: 'g1_0700' },
                            { len: 0.35, cost: getPrice('g1_0350', 2.53), k: 'g1_0350' }
                        ];

                        if (isManual) {
                            // Modo Manual: Forzamos el uso repetido del perfil seleccionado
                            // Sin optimizaci√≥n de mezcla, solo repetici√≥n.
                            let remaining = railLen;
                            segments = [];
                            while (remaining > 0.005) {
                                let useLen = (railUnit || 2.35);
                                let actual = Math.min(remaining, useLen);
                                segments.push({ len: actual, type: railUnit });
                                remaining -= actual;
                            }
                        } else {
                            // MODO AUTO: SOLVER RECURSIVO PARA M√çNIMO COSTE
                            // Encuentra la combinaci√≥n √≥ptima de perfiles
                            const memo = {};

                            const solve = (remLen) => {
                                // Cuantizar longitud para evitar errores de float en keys
                                const key = Math.round(remLen * 100);
                                if (memo[key]) return memo[key];

                                let best = { cost: Infinity, segs: [] };

                                // Caso base: longitud cubierta
                                if (remLen <= 0.005) return { cost: 0, segs: [] };

                                // Opci√≥n A: Cerrar fila con una pieza final (cualquiera que quepa/sobre)
                                for (let s of stock) {
                                    if (s.len >= remLen - 0.005) {
                                        // Esta pieza es suficiente para terminar
                                        if (s.cost < best.cost) {
                                            best = {
                                                cost: s.cost,
                                                segs: [{ len: remLen, type: s.len }]
                                            };
                                        }
                                    }
                                }

                                // Opci√≥n B: Usar pieza intermedia y seguir
                                // Limitamos las intermedias a >= 1.20m para evitar puzzles de micro-piezas
                                for (let s of stock) {
                                    if (s.len >= 1.20 && remLen > s.len) {
                                        const res = solve(remLen - s.len);
                                        if (res.cost + s.cost < best.cost) {
                                            best = {
                                                cost: res.cost + s.cost,
                                                segs: [{ len: s.len, type: s.len }, ...res.segs]
                                            };
                                        }
                                    }
                                }

                                memo[key] = best;
                                return best;
                            };

                            const solution = solve(railLen);
                            segments = solution.segs;
                        }

                        // 3. BOM Calculation (Using keys from stock logic would be cleaner, but keeping map loop for robustness)
                        segments.forEach(s => {
                            const t = s.type;
                            // Helper to find closest stock key
                            const match = stock.find(st => Math.abs(st.len - t) < 0.05);
                            if (match) {
                                if (!totalBom[match.k]) totalBom[match.k] = 0;
                                totalBom[match.k] += 2; // 2 rails per structure
                            }
                        });

                        totalBom.g_union += Math.max(0, segments.length - 1) * 2;
                    }

                    // BOM Tapas y Presores (Gen√©rico) stays same
                    const pCount = rowPanels.length;
                    totalBom.tapa += 4;
                    totalBom.s02_3 += numAnc * 2;
                    if (pCount > 0) {
                        totalBom.s10 += 4;
                        totalBom.s11 += Math.max(0, pCount - 1) * 2;
                    }
                }

                // Dibujar 2 rieles 
                [0.25, 0.75].forEach(factor => {
                    const railY = yPos + pHeight * factor;
                    verticalRailPositions.add(railY);
                    const zOffset = 0.09;

                    // Riel (Perfil) - Dibujar por segmentos para diferenciar colores

                    // Colores por tipo de perfil (Mapa extendido)
                    const matMap = {
                        0.35: new THREE.MeshPhongMaterial({ color: 0xecf0f1 }),
                        0.70: new THREE.MeshPhongMaterial({ color: 0xbdc3c7 }),
                        0.80: new THREE.MeshPhongMaterial({ color: 0x95a5a6 }),
                        0.90: new THREE.MeshPhongMaterial({ color: 0x7f8c8d }),
                        1.10: new THREE.MeshPhongMaterial({ color: 0xaed6f1 }),
                        1.23: new THREE.MeshPhongMaterial({ color: 0x3498db }),
                        1.45: new THREE.MeshPhongMaterial({ color: 0x5dade2 }),
                        1.80: new THREE.MeshPhongMaterial({ color: 0x1abc9c }),
                        2.20: new THREE.MeshPhongMaterial({ color: 0x8e44ad }),
                        2.35: new THREE.MeshPhongMaterial({ color: 0x9b59b6 }),
                        3.60: new THREE.MeshPhongMaterial({ color: 0x27ae60 }),
                        4.40: new THREE.MeshPhongMaterial({ color: 0xd35400 }),
                        4.80: new THREE.MeshPhongMaterial({ color: 0xc0392b }),
                    };
                    const matGeneric = new THREE.MeshPhongMaterial({ color: 0xc0c0c0 }); // Silver

                    if (!isSunfer && segments.length > 0) {
                        const railStart = centerX - railLen / 2;
                        let currentX = railStart;

                        segments.forEach(seg => {
                            const segLen = seg.len;
                            const segType = seg.type; // Source Type

                            const segGeo = new THREE.BoxGeometry(segLen - 0.005, 0.045, 0.045); // Gap visual
                            let segMat = matGeneric;

                            // Asignar color buscando en el mapa (con tolerancia)
                            for (let k in matMap) {
                                if (Math.abs(segType - parseFloat(k)) < 0.05) {
                                    segMat = matMap[k];
                                    break;
                                }
                            }

                            const segMesh = new THREE.Mesh(segGeo, segMat);
                            segMesh.position.set(currentX + segLen / 2, railY, zOffset);
                            parentGroup.add(segMesh);

                            // Etiqueta de Recorte (Usando el tipo de perfil correcto como referencia)
                            if (Math.abs(segLen - segType) > 0.05 && segLen < segType) {
                                const cutAmount = Math.round((segType - segLen) * 100);
                                if (cutAmount > 0) {
                                    const cutLbl = makeTextSprite(`Recorte: -${cutAmount}cm`, "rgba(255, 50, 50, 1.0)");
                                    const scaleFactor = 0.6;
                                    cutLbl.scale.x *= scaleFactor;
                                    cutLbl.scale.y *= scaleFactor;
                                    cutLbl.position.set(currentX + segLen / 2, railY + 0.05, zOffset + 0.1);
                                    parentGroup.add(cutLbl);
                                }
                            }

                            currentX += segLen;
                        });

                        // Dibujar Uniones (Splices) entre segmentos
                        if (segments.length > 1) {
                            let spliceX = railStart;
                            for (let s = 0; s < segments.length - 1; s++) {
                                spliceX += segments[s].len; // Access .len property
                                const gSpliceGeo = new THREE.BoxGeometry(0.1, 0.052, 0.052);
                                const gSpliceMat = new THREE.MeshPhongMaterial({ color: 0x2c3e50 });
                                const gSplice = new THREE.Mesh(gSpliceGeo, gSpliceMat);
                                gSplice.position.set(spliceX, railY, zOffset);
                                parentGroup.add(gSplice);
                            }
                        }

                    } else {
                        // Sunfer o fallback: bloque √∫nico
                        const railGeo = new THREE.BoxGeometry(railLen, 0.045, 0.045);
                        const railMat = new THREE.MeshPhongMaterial({ color: 0xc0c0c0 });
                        const rail = new THREE.Mesh(railGeo, railMat);
                        rail.position.set(centerX, railY, zOffset);
                        parentGroup.add(rail);
                    }

                    // Tapa G1 (Black Caps on ends) - Aplicar a todos
                    const capGeo = new THREE.BoxGeometry(0.01, 0.048, 0.048);
                    const capMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
                    const capL = new THREE.Mesh(capGeo, capMat);
                    capL.position.set(centerX - railLen / 2 - 0.005, railY, zOffset);
                    parentGroup.add(capL);

                    const capR = new THREE.Mesh(capGeo, capMat);
                    capR.position.set(centerX + railLen / 2 + 0.005, railY, zOffset);
                    parentGroup.add(capR);

                    if (isSunfer) {
                        // Visualizar Uniones (Splices) - UG1
                        const d = sunferData[n];
                        if (d && d.bom && d.bom.ug1 > 0) {
                            const splicesPerLine = d.bom.ug1 / 2;
                            if (splicesPerLine >= 1) {
                                const segmentLen = railLen / (splicesPerLine + 1);
                                for (let s = 1; s <= splicesPerLine; s++) {
                                    const sx = (centerX - railLen / 2) + segmentLen * s;
                                    const spliceGeo = new THREE.BoxGeometry(0.15, 0.055, 0.055);
                                    const spliceMat = new THREE.MeshPhongMaterial({ color: 0x2980b9 });
                                    const spliceMesh = new THREE.Mesh(spliceGeo, spliceMat);
                                    spliceMesh.position.set(sx, railY, zOffset);
                                    parentGroup.add(spliceMesh);
                                }
                            }
                        }
                    }

                    // Dibujar anclajes (HOOKS)
                    anchorsCoords.forEach(ax => {
                        const ancGroup = new THREE.Group();

                        // Base part (under rail) - Bigger
                        const ancGeo = new THREE.BoxGeometry(0.1, 0.18, 0.04);
                        const ancMat = new THREE.MeshPhongMaterial({ color: 0xff4500 }); // Always use Orange (S02.3)
                        const anc = new THREE.Mesh(ancGeo, ancMat);
                        anc.position.set(0, 0, 0);
                        ancGroup.add(anc);

                        // Vertical part (to roof) - Long Leg (Salvatajas)
                        const legGeo = new THREE.BoxGeometry(0.05, 0.05, 0.25); // 25cm height (very tall)
                        const leg = new THREE.Mesh(legGeo, ancMat);
                        leg.position.set(0, 0.08, -0.12); // Reaching down
                        ancGroup.add(leg);

                        // Position just under the rail
                        ancGroup.position.set(ax, railY, 0.05);
                        parentGroup.add(ancGroup);
                    });

                    // Draw dimensions if enabled
                    if (document.getElementById('viewDimensions')?.checked) {
                        const startRailX = centerX - railLen / 2;
                        const endRailX = centerX + railLen / 2;

                        // Calculate exact intersection of rail line with roof edges (for trapezoid accuracy)
                        let rowLeftX = Math.min(...vertices.map(v => v.x));
                        let rowRightX = Math.max(...vertices.map(v => v.x));

                        // Find intersection of y=railY with roof edges
                        const xIntersections = [];
                        for (let k = 0; k < vertices.length; k++) {
                            const v1 = vertices[k], v2 = vertices[(k + 1) % vertices.length];
                            if ((v1.y <= railY && v2.y > railY) || (v1.y > railY && v2.y <= railY)) {
                                const t = (railY - v1.y) / (v2.y - v1.y);
                                xIntersections.push(v1.x + t * (v2.x - v1.x));
                            }
                        }
                        if (xIntersections.length >= 2) {
                            xIntersections.sort((a, b) => a - b);
                            rowLeftX = xIntersections[0];
                            rowRightX = xIntersections[xIntersections.length - 1];
                        }

                        // Horizontal dimensions line: RoofLeft -> RailStart -> Anchors -> RailEnd -> RoofRight
                        const dimY = railY - 0.25;
                        const dimZ = 0.25;

                        // Pass key points with exact roof edges
                        const keyPoints = [startRailX, ...anchorsCoords, endRailX];
                        drawDimensions(parentGroup, rowLeftX, rowRightX, keyPoints, dimY, dimZ);
                    }
                });

                // Dibujar Clamps (Presores) - Spot Clamps aligned with rails
                const clampZ = 0.125;
                // Colores distintos y llamativos
                const matS10 = new THREE.MeshPhongMaterial({ color: 0xe74c3c }); // Bright Red
                const matS11 = new THREE.MeshPhongMaterial({ color: 0x2ecc71 }); // Bright Green

                [0.25, 0.75].forEach(factor => {
                    const railY = yPos + pHeight * factor;

                    // S10 Laterales (End Clamps) - 60mm length
                    const geoS10 = new THREE.BoxGeometry(0.04, 0.06, 0.03);

                    // Left End S10
                    const s10L = new THREE.Mesh(geoS10, matS10);
                    s10L.position.set(minX - 0.015, railY, clampZ);
                    parentGroup.add(s10L);

                    // Right End S10
                    const s10R = new THREE.Mesh(geoS10, matS10);
                    s10R.position.set(maxX + 0.015, railY, clampZ);
                    parentGroup.add(s10R);

                    // S11 Centrales (Inter Clamps)
                    const geoS11 = new THREE.BoxGeometry(0.02, 0.06, 0.035); // Slightly taller

                    for (let i = 0; i < n - 1; i++) {
                        const pCur = rowPanels[i];
                        const pNext = rowPanels[i + 1];
                        const midX = (pCur.x + pCur.w + pNext.x) / 2;

                        const s11 = new THREE.Mesh(geoS11, matS11);
                        s11.position.set(midX, railY, clampZ);
                        parentGroup.add(s11);
                    }
                });

            });

            updateBOM(totalBom);
            drawVerticalDimensions(parentGroup, Array.from(verticalRailPositions));
        }

        function drawVerticalDimensions(group, yPositions) {
            const show = document.getElementById('viewDimensions')?.checked;
            if (!show || yPositions.length === 0) return;

            yPositions.sort((a, b) => a - b);

            // Draw on the left side of the roof geometry
            const roofMinX = Math.min(...vertices.map(v => v.x));
            const xPos = roofMinX - 0.4;
            const zPos = 0.2;
            const color = "rgba(0, 255, 255, 1.0)"; // Cyan for vertical dims
            const lineMat = new THREE.LineBasicMaterial({ color: 0x00ffff });

            // Include 0 (Bottom) and Top (Height) to measure full vertical usage
            const roofHeight = Math.max(...vertices.map(v => v.y));
            const points = [0, ...yPositions, roofHeight];

            for (let i = 0; i < points.length - 1; i++) {
                const y1 = points[i];
                const y2 = points[i + 1];
                const dist = y2 - y1;

                // Draw Vertical Line Segment
                const geo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(xPos, y1, zPos),
                    new THREE.Vector3(xPos, y2, zPos)
                ]);
                group.add(new THREE.Line(geo, lineMat));

                // Ticks
                const tLen = 0.1;
                const t1 = new THREE.Line(new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(xPos - tLen, y1, zPos), new THREE.Vector3(xPos + tLen, y1, zPos)
                ]), lineMat);
                const t2 = new THREE.Line(new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(xPos - tLen, y2, zPos), new THREE.Vector3(xPos + tLen, y2, zPos)
                ]), lineMat);
                group.add(t1); group.add(t2);

                // Text
                const midY = (y1 + y2) / 2;
                // Smart formatting
                let msg = dist.toFixed(2) + 'm';
                if (dist < 1.0) msg = Math.round(dist * 100) + 'cm';

                const lbl = makeTextSprite(msg, color);
                // Stagger vertical dims too if needed? Usually vertical spacing is larger (rails).
                // But for safety:
                const staggerX = (i % 2 === 1) ? -0.15 : 0;
                lbl.position.set(xPos - 0.3 + staggerX, midY, zPos);
                group.add(lbl);
            }
        }

        function generateLayout() {
            const rIn = document.getElementById('genRows'), cIn = document.getElementById('genCols');
            const oIn = document.getElementById('genOrient'), lIn = document.getElementById('pLength'), wIn = document.getElementById('pWidth');

            if (!rIn || !cIn || !oIn || !lIn || !wIn) return;

            const rows = parseInt(rIn.value), cols = parseInt(cIn.value), orient = oIn.value;
            const pL = parseFloat(lIn.value) / 1000, pW = parseFloat(wIn.value) / 1000;

            const w = orient === 'v' ? pW : pL;
            const h = orient === 'v' ? pL : pW;

            panels = [];
            let minX = Math.min(...vertices.map(v => v.x)), maxX = Math.max(...vertices.map(v => v.x));

            // C√°lculo milim√©trico de ancho total: paneles + (gaps entre paneles)
            const totalW = cols * w + (Math.max(0, cols - 1) * P_GAP);
            const startX = (maxX - minX - totalW) / 2;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    panels.push({
                        id: 'p_' + Math.random().toString(36).substr(2, 9),
                        row: r,
                        x: startX + c * (w + P_GAP),
                        y: 0.1 + r * (h + P_GAP),
                        w: w, h: h
                    });
                }
            }
            updateView();
            focusCamera(); // Auto-center 
        }

        function focusCamera() {
            if (!panelsGroup || panelsGroup.children.length === 0) return;

            // Ensure world matrices are up to date for accurate box calculation
            panelsGroup.updateMatrixWorld(true);

            const box = new THREE.Box3().setFromObject(panelsGroup);
            if (box.isEmpty()) return;

            const center = new THREE.Vector3();
            box.getCenter(center);

            const size = new THREE.Vector3();
            box.getSize(size);

            const maxDim = Math.max(size.x, size.y, size.z);

            if (camera && controls) {
                controls.target.copy(center);
                // Tighter zoom: 1.2 factor instead of 1.5
                const dist = Math.max(3, maxDim * 1.2);

                // Position camera nicely
                // If it's a flat layout, we mostly care about Z distance
                // We add a bit of Y offset for perspective
                camera.position.set(center.x, center.y + dist * 0.3, center.z + dist);
                controls.update();
            }
        }

        function toggleUI() {
            const ui = document.getElementById('ui-panel');
            const isMobile = window.innerWidth <= 1024;

            if (isMobile) {
                ui.classList.toggle('mobile-view-open');
            } else {
                ui.classList.toggle('hidden');
            }
            updateUIState();
        }

        function updateView() {
            if (roofMesh) scene.remove(roofMesh);
            const shape = new THREE.Shape();
            if (vertices.length < 3) return;

            shape.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < vertices.length; i++) shape.lineTo(vertices[i].x, vertices[i].y);
            shape.lineTo(vertices[0].x, vertices[0].y);

            const slopeInput = document.getElementById('roofSlope');
            if (!slopeInput) return;

            const slope = parseFloat(slopeInput.value);
            roofMesh = new THREE.Mesh(new THREE.ExtrudeGeometry(shape, { depth: 0.05, bevelEnabled: false }),
                new THREE.MeshPhongMaterial({ color: 0x8b4513, transparent: true, opacity: 0.7, side: THREE.DoubleSide }));
            let minX = Math.min(...vertices.map(v => v.x)), maxX = Math.max(...vertices.map(v => v.x));
            roofMesh.position.set(-(minX + maxX) / 2, 4.05, 3.0);
            roofMesh.rotation.x = -Math.PI / 2 + (slope * Math.PI / 180);
            scene.add(roofMesh);
            renderPanels();
        }

        function renderPanels() {
            if (!panelsGroup) return;
            panelsGroup.clear();

            const sIn = document.getElementById('roofSlope'), vIn = document.getElementById('pVoc'), mIn = document.getElementById('pVmpH');
            const vsIn = document.getElementById('invVstart'), vmIn = document.getElementById('invVmin');

            if (!sIn || !vIn || !mIn || !vsIn || !vmIn) return;

            const slope = parseFloat(sIn.value), pVoc = parseFloat(vIn.value), pVmpH = parseFloat(mIn.value);
            const vStartLimit = parseFloat(vsIn.value), vMinLimit = parseFloat(vmIn.value);

            let minX = Math.min(...vertices.map(v => v.x)), maxX = Math.max(...vertices.map(v => v.x));
            const pivot = new THREE.Group();
            pivot.position.set(-(minX + maxX) / 2, 4.05, 3.0);
            pivot.rotation.x = -Math.PI / 2 + (slope * Math.PI / 180);
            let anyPositionError = false;

            const hidePanels = document.getElementById('viewStructureOnly')?.checked;

            panels.forEach(p => {
                const status = checkSafety(p);
                let color = 0x111122;
                if (status === 'warn') color = 0x27ae60;
                if (status === 'err') { color = 0xc0392b; anyPositionError = true; }
                const m = new THREE.Mesh(new THREE.PlaneGeometry(p.w, p.h), new THREE.MeshPhongMaterial({ color: color, side: THREE.DoubleSide }));
                m.position.set(p.x + p.w / 2, p.y + p.h / 2, 0.1);
                m.userData.id = p.id;
                m.add(new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.PlaneGeometry(p.w, p.h)), new THREE.LineBasicMaterial({ color: 0x444444 })));

                if (hidePanels) {
                    m.visible = false;
                }

                pivot.add(m);
            });

            // Render Structure (New)
            renderStructure(pivot);

            panelsGroup.add(pivot);

            const vTotalVoc = panels.length * pVoc;
            const vTotalVmpH = panels.length * pVmpH;

            const stVocEl = document.getElementById('st-voc'), stVmpEl = document.getElementById('st-vmp');
            const stCountEl = document.getElementById('st-count'), msgEl = document.getElementById('safety-msg');

            if (stVocEl) stVocEl.innerText = vTotalVoc.toFixed(1) + " V";
            if (stVmpEl) stVmpEl.innerText = vTotalVmpH.toFixed(1) + " V";
            if (stCountEl) stCountEl.innerText = panels.length;

            if (msgEl) {
                const voltageOk = vTotalVoc >= vStartLimit && vTotalVmpH >= vMinLimit;
                if (!anyPositionError && voltageOk && panels.length > 0) {
                    msgEl.innerText = "DISE√ëO CORRECTO";
                    msgEl.className = "warning ok";
                } else if (!voltageOk && panels.length > 0) {
                    msgEl.innerText = "¬°ALERTA: VOLTAJE INSUFICIENTE!";
                    msgEl.className = "warning err";
                } else if (anyPositionError) {
                    msgEl.innerText = "¬°REVISAR POSICI√ìN DE PANELES!";
                    msgEl.className = "warning err";
                } else {
                    msgEl.innerText = "SIN PANELES INSTALADOS";
                    msgEl.className = "warning";
                }
            }
        }

        function syncFromStandard() {
            const bIn = document.getElementById('roofB'), tIn = document.getElementById('roofT');
            const hIn = document.getElementById('roofH'), mIn = document.getElementById('roofPreset');

            if (!bIn || !tIn || !hIn || !mIn) return;

            const b = parseFloat(bIn.value), t = parseFloat(tIn.value), h = parseFloat(hIn.value), mode = mIn.value;

            if (mode === 'rectangulo') vertices = [{ x: 0, y: 0 }, { x: b, y: 0 }, { x: b, y: h }, { x: 0, y: h }];
            else if (mode === 'trapecio') { const off = (b - t) / 2; vertices = [{ x: 0, y: 0 }, { x: b, y: 0 }, { x: b - off, y: h }, { x: off, y: h }]; }
            else vertices = [{ x: 0, y: 0 }, { x: b, y: 0 }, { x: t, y: h }, { x: 0, y: h }];
            updateView();
        }

        function setMoveTarget(t) {
            moveTarget = t;
            document.querySelectorAll('.row-opt').forEach(el => el.classList.remove('active'));
            const tgtEl = document.getElementById('tgt-' + t);
            if (tgtEl) tgtEl.classList.add('active');
        }

        function movePanel(dx, dy) {
            saveState(); // Save before move
            panels.forEach(p => { if (moveTarget === 'all' || p.row === moveTarget) { p.x += dx; p.y += dy; } });
            renderPanels();
        }

        function drawDimensions(group, startX, endX, anchors, y, z) {
            const show = document.getElementById('viewDimensions')?.checked;
            if (!show) return;

            const points = [startX, ...anchors, endX].sort((a, b) => a - b);
            const lineMat = new THREE.LineBasicMaterial({ color: 0xffff00 });

            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i + 1];
                const dist = p2 - p1;
                if (dist < 0.01) continue;

                // Draw Line
                const geo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(p1, y, z),
                    new THREE.Vector3(p2, y, z)
                ]);
                const line = new THREE.Line(geo, lineMat);
                group.add(line);

                // Draw Ticks
                const tickH = 0.05;
                const t1 = new THREE.Line(new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(p1, y - tickH, z), new THREE.Vector3(p1, y + tickH, z)
                ]), lineMat);
                const t2 = new THREE.Line(new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(p2, y - tickH, z), new THREE.Vector3(p2, y + tickH, z)
                ]), lineMat);
                group.add(t1);
                group.add(t2);

                // Draw Text
                const mid = (p1 + p2) / 2;

                // Smart formatting (cm if small)
                let msg = dist.toFixed(2) + 'm';
                if (dist < 1.0) msg = Math.round(dist * 100) + 'cm';

                const label = makeTextSprite(msg);

                // Stagger labels to avoid overlap (Zigzag)
                // Base Y offset is -0.1. We alternate adding -0.15 more.
                const stagger = (i % 2 === 1) ? -0.12 : 0;
                label.position.set(mid, y - 0.1 + stagger, z);
                group.add(label);
            }
        }

        function makeTextSprite(message, colorStr = "rgba(255, 255, 0, 1.0)") {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const fontSize = 48;
            context.font = "Bold " + fontSize + "px Arial";
            const metrics = context.measureText(message);
            const textWidth = metrics.width;

            canvas.width = textWidth + 20;
            canvas.height = fontSize + 20;

            context.fillStyle = "rgba(0,0,0,0.6)";
            context.fillRect(0, 0, canvas.width, canvas.height); // Background

            context.font = "Bold " + fontSize + "px Arial";
            context.fillStyle = colorStr;
            context.fillText(message, 10, fontSize);

            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMat);
            // Reduced scale from 0.4 to 0.25 for smaller labels
            sprite.scale.set(0.25 * (canvas.width / 100), 0.25 * (canvas.height / 100), 1);
            return sprite;
        }

        function saveProject() {
            const data = {
                inputs: {},
                bomPrices: bomPrices,
                moveTarget: moveTarget
            };

            // Save Inputs
            document.querySelectorAll('input, select').forEach(el => {
                if (el.id && el.id !== 'file-input') {
                    if (el.type === 'checkbox') data.inputs[el.id] = el.checked;
                    else data.inputs[el.id] = el.value;
                }
            });

            // Save Panels (Positions)
            data.panels = panels.map(p => ({
                id: p.id, row: p.row, x: p.x, y: p.y, w: p.w, h: p.h
            }));

            const jsonStr = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = "config_solar.json";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function loadProject(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Restore Inputs
                    if (data.inputs) {
                        for (const id in data.inputs) {
                            const el = document.getElementById(id);
                            if (el) {
                                if (el.type === 'checkbox') el.checked = data.inputs[id];
                                else el.value = data.inputs[id];
                            }
                        }
                    }

                    // Restore State
                    if (data.bomPrices) bomPrices = data.bomPrices;
                    if (data.moveTarget) setMoveTarget(data.moveTarget);

                    // Restore Layout Logic
                    // 1. Sync Roof
                    syncFromStandard();

                    // 2. Sync Presets (Enables/Disables inputs)
                    applyPanelPreset();
                    applyInverterPreset();

                    // 3. Restore Panels (Position Override)
                    if (data.panels && Array.isArray(data.panels)) {
                        panels = data.panels;
                    } else {
                        generateLayout();
                    }

                    // 4. Render
                    renderStructureWrapper(); // Calls renderPanels + updateBOM

                } catch (err) {
                    console.error(err);
                    alert("Error al cargar el archivo de configuraci√≥n.");
                }
            };
            reader.readAsText(file);
            input.value = ''; // Reset for next load
        }

        function exportCSV() {
            const rows = document.querySelectorAll('#bom-container tr');
            if (rows.length === 0) { alert("Genere la estructura primero."); return; }

            let csvContent = "\ufeff"; // BOM for Excel
            rows.forEach(row => {
                const cols = row.querySelectorAll('th, td');
                let rowData = [];
                cols.forEach(col => {
                    let text = col.innerText.replace('\n', ' ').trim();
                    const input = col.querySelector('input');
                    if (input) text = input.value;
                    rowData.push('"' + text + '"');
                });
                csvContent += rowData.join(";") + "\n";
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = "presupuesto_solar.csv";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        async function exportPDF() {
            const { jsPDF } = window.jspdf;
            if (!jsPDF) { alert("Librer√≠a PDF no cargada. Recargue la p√°gina."); return; }

            const doc = new jsPDF();
            doc.setFontSize(18);
            doc.text("Presupuesto Estructura Solar", 105, 20, null, null, "center");

            doc.setFontSize(10);
            const dateStr = new Date().toLocaleDateString();
            doc.text("Fecha: " + dateStr, 105, 28, null, null, "center");

            // 1. Capture 3D Scene
            if (renderer && scene && camera) {
                // Ensure render is fresh
                renderer.render(scene, camera);
                const imgData = renderer.domElement.toDataURL("image/jpeg", 0.9);

                // Add Image (Fit to width)
                const imgProps = doc.getImageProperties(imgData);
                const pdfWidth = doc.internal.pageSize.getWidth();
                const margin = 15;
                const imgWidth = pdfWidth - (margin * 2);
                const imgHeight = (imgProps.height * imgWidth) / imgProps.width;

                doc.addImage(imgData, 'JPEG', margin, 35, imgWidth, imgHeight);

                // Move cursor down for table
                var finalY = 35 + imgHeight + 10;
            } else {
                var finalY = 40;
            }

            // 2. Add BOM Table
            const table = document.querySelector('#bom-container table');
            if (!table) { alert("Genere la estructura primero."); return; }

            // Extract Headers
            let head = [];
            const ths = table.querySelectorAll('thead tr th');
            if (ths.length > 0) {
                let rowHead = [];
                ths.forEach(th => rowHead.push(th.innerText));
                head.push(rowHead);
            }

            // Extract Body
            let body = [];
            table.querySelectorAll('tbody tr').forEach(tr => {
                let row = [];
                const tds = tr.querySelectorAll('td');
                tds.forEach((td, index) => {
                    // Col 0: Concept, Col 1: Qty -> Text only
                    // Col 2: Price (Input), Col 3: Total -> Currency
                    if (index === 2) {
                        const input = td.querySelector('input');
                        const val = input ? input.value : '0.00';
                        row.push(val + ' ‚Ç¨');
                    } else if (index === 3) {
                        row.push(td.innerText.trim()); // Already has ‚Ç¨ in HTML
                    } else {
                        row.push(td.innerText.trim());
                    }
                });
                body.push(row);
            });

            // Footer (Total) logic if not in table body
            // (Assuming existing code might calculate total elsewhere, but let's check BOM total manually or via DOM)
            // Grand total is usually in the last col of rows, but let's recalculate or just take what's there.

            doc.autoTable({
                head: head,
                body: body,
                startY: finalY,
                theme: 'grid',
                headStyles: { fillColor: [41, 128, 185], halign: 'center' },
                columnStyles: {
                    0: { halign: 'left' },
                    1: { halign: 'center' },
                    2: { halign: 'right' },
                    3: { halign: 'right', fontStyle: 'bold' }
                },
                foot: [['', '', 'TOTAL:', '']] // Placeholder if needed
            });

            // Calculate total from data if needed to put in footer
            // But usually the user wants to see what's on screen.
            // Let's add the Project Summary text if available (Voc/Vmp)

            const voc = document.getElementById('st-voc')?.innerText || '';
            const vmp = document.getElementById('st-vmp')?.innerText || '';
            const panelsCount = document.getElementById('st-count')?.innerText || '';

            let finalYTable = doc.lastAutoTable.finalY + 10;

            doc.setFontSize(10);
            doc.text(`Resumen T√©cnico:`, 14, finalYTable);
            doc.setFontSize(9);
            doc.text(`- Paneles: ${panelsCount}`, 14, finalYTable + 6);
            doc.text(`- Voc Total: ${voc}`, 14, finalYTable + 11);
            doc.text(`- Vmp Total: ${vmp}`, 14, finalYTable + 16);

            doc.save("presupuesto_solar_v1.0.9.pdf");
        }

        // Initialize with default Obramat/Market approximate prices
        bomPrices = {
            s02_3: 8.50, // Soporte
            s10: 1.80,   // Presor Lat
            s11: 1.80,   // Presor Cen
            ug1: 3.50,   // Uni√≥n
            g1_0350: 2.53,
            g1_0700: 4.50,
            g1_0800: 5.00,
            g1_0900: 6.00,
            g1_1100: 7.00,
            g1_1230: 8.99,
            g1_1450: 10.00,
            g1_1800: 14.00,
            g1_2200: 18.00,
            g1_2350: 17.95,
            g1_3600: 30.99,
            g1_4400: 35.00,
            g1_4800: 38.00,
            tapa: 0.75,
            s13: 0.30,
            g_rail: 7.00,
            g_union: 3.50
        };

        function animate() { requestAnimationFrame(animate); if (controls) controls.update(); if (renderer && scene && camera) renderer.render(scene, camera); }
        window.onload = init;
        window.onresize = () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        };
    </script>
</body>

</html>